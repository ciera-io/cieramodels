// BP 7.1.6 content: InstanceStateMachine syschar: 3 persistence-version: 7.1.6

within Location::Location::Location::Location::GPS is

  @state_num(1);
  @dialect("oal");
  state idle;

  @state_num(2);
  @dialect("oal");
  state locating;

  @state_num(3);
  @dialect("oal");
  state registeringListener;

  @state_num(5);
  @dialect("oal");
  state unregistering;

  @event_num(1);
  event tick;

  @event_num(4);
  event registeringComplete;

  @event_num(10);
  event registerListener;

  @event_num(11);
  event unregisterListener;

  @event_num(12);
  event unregisterComplete;

  state machine is

    |                     | tick                | registeringComplete | registerListener    | unregisterListener  | unregisterComplete  |
    | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- | ------------------- |
    | idle                | cannot_happen       | cannot_happen       | registeringListener | cannot_happen       | cannot_happen       |
    | locating            | locating            | cannot_happen       | cannot_happen       | unregistering       | cannot_happen       |
    | registeringListener | cannot_happen       | locating            | cannot_happen       | cannot_happen       | cannot_happen       |
    | unregistering       | cannot_happen       | cannot_happen       | cannot_happen       | cannot_happen       | idle                |

  end state machine;

  state idle is
    @noparse
    LOG::LogInfo( message:"Locating::GPS::Idle" );
    @endnoparse
  end state;

  state locating is
    @noparse
    // Simulate movement.
    simulatedGPS::initialize();
    select any simgps from instances of simulatedGPS;
    if ( (self.motionSegments % 3) == 0 )
      self.currentLongitude = self.currentLongitude + (simgps.longitudeIncrement * 2);
      self.currentLatitude = self.currentLatitude + simgps.latitudeIncrement;
    elif ( (self.motionSegments %5) == 0 )
      self.currentLongitude = self.currentLongitude + simgps.longitudeIncrement;
      self.currentLatitude = self.currentLatitude + (simgps.latitudeIncrement * 3);
    else
      self.currentLongitude = self.currentLongitude + simgps.longitudeIncrement;
      self.currentLatitude = self.currentLatitude + simgps.latitudeIncrement;
    end if;
    // Increment simulated motion segment count.
    self.motionSegments = self.motionSegments + 1;
    // send signal to tracking
    send LOC::locationChanged( latitude:self.currentLatitude, longitude:self.currentLongitude );
    @endnoparse
  end state;

  state registeringListener is
    @noparse
    // Activate the simulated GPS (this creates the GPS instance, if needed).
    // Establish recurring timer for periodic position updates.
    simulatedGPS::initialize();
    select any simgps from instances of simulatedGPS;
    create event instance tick of GPS1:tick() to self;
    self.timer = TIM::timer_start_recurring( event_inst: tick, microseconds: simgps.updatePeriod );
    LOG::LogInfo(message: "Location listener registered.");  
    
    generate GPS4:registeringComplete() to self;
    @endnoparse
  end state;

  state unregistering is
    @noparse
    // Deactivate the timer.
    res = TIM::timer_cancel(timer_inst_ref: self.timer);
    LOG::LogInfo(message: "Location listener unregistered.");
    
    if ( not res )
      LOG::LogFailure( message: "Location listener: timer_cancel() failed." );
    end if;
    generate GPS12:unregisterComplete() to self;
    @endnoparse
  end state;

end;
