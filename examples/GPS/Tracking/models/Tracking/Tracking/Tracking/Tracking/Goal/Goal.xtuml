// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within Tracking::Tracking::Tracking::Tracking is

  //! Each instance represents a particular goal as it is executing.
  //! This class knows how to evaluate whether the goal is being achieved
  //! and whether the goal has completed.
  @key_letters("Goal");
  @class_num(9);
  class Goal is

    @ref_mode("referred_to");
    @use_prefix(prefix="session_", root_name="startTime");
    session_startTime: referential (R13.WorkoutSession.startTime, R9.GoalSpec.session_startTime, R11.WorkoutSession.startTime) timestamp;

    @ref_mode("referred_to");
    @use_prefix(prefix="spec_", root_name="sequenceNumber");
    spec_sequenceNumber: referential (R9.GoalSpec.sequenceNumber) integer;

    //! An arbitrary identifier.
    ID: integer;

    //! Captures the starting point of the span for this particular goal so
    //! that the end of the goal execution period can be determined.  In other
    //! words, using the value of this attribute together with the span specified
    //! by the associated goal specification, the goal knows when it is finished.
    //! 
    //! For distance-based goals, it is expressed as the accumulated distance
    //! in meters for the associated workout session at the time this goal
    //! execution commenced.
    //! 
    //! For time-based goals, it is expressed as the elapsed time in seconds
    //! for the associated workout session at the time this goal execution
    //! commenced.
    startingPoint: real;

    //! The disposition of this goal.  See data type descriptions for details.
    //! This attribute represents the logical or semantic disposition of the goal.
    //! For example, a disposition indicating the need to increase the value in question
    //! for a heart-rate goal means that activity should be increased to drive up the
    //! heart rate.  Since pace is the inverse of speed, a disposition indicating
    //! the need to increase the value in question (pace) means that the user must
    //! increase speed, causing a lower (faster) pace number.
    disposition: GoalDisposition;

    //! Handle for the timer used for periodic evaluation of goal achievement.
    evaluationTimer: timer;

    preferred identifier is (session_startTime, spec_sequenceNumber, ID);

    @dialect("oal");
    class operation initialize(sequenceNumber: in integer) is
      @noparse
      // Create and activate an instance of a goal specified by
      //   the goal specification, if it exists, identified by 
      //   the incoming parameter.
      
      // Find the goal specification for this goal, then
      //   create and relate this goal to the specification
      //   and to the singleton workout session.
      select any goalSpec from instances of GoalSpec where ( selected.sequenceNumber == param.sequenceNumber );
      if ( not empty goalSpec )
        create object instance goal of Goal; goal.ID = goalSpec.last_goal_ID + 1;
        relate goal to goalSpec across R9.'specified_by';
        select any session from instances of WorkoutSession;  // WorkoutSession is a singleton
        relate goal to session across R11.'is_currently_executing_within';
        goalSpec.last_goal_ID = goal.ID;
      
        // Initialize this goal.
        goal.calculateStart();
        goal.disposition = GoalDisposition::Increase;
      
        // Start a timer that periodically causes evaluation of goal achievement.
        GoalAchievement::initialize();
        select any goalachievement from instances of GoalAchievement;
        create event instance evaluateEvent of Goal2:Evaluate to goal; goal.evaluationTimer = TIM::timer_start_recurring( event_inst: evaluateEvent, microseconds: goalachievement.evaluationPeriod );
      end if;
      @endnoparse
    end operation;

    @dialect("oal");
    operation calculateStart() is
      @noparse
      // Based on the span type for this goal, calculate and
      //   store the value of the start attribute.
      select one goalSpec related by self->GoalSpec[R9.'specified_by'];
      if ( goalSpec.spanType == GoalSpan::Time )
        select one workoutTimer related by self->WorkoutSession[R11.'is_currently_executing_within']->WorkoutTimer[R8.'is_timed_by'];
        self.startingPoint = workoutTimer.time;
      elif ( goalSpec.spanType == GoalSpan::Distance )
        select one session related by self->WorkoutSession[R11.'is_currently_executing_within'];
        self.startingPoint = session.accumulatedDistance;
      else
        LOG::LogFailure( message: "Goal.calculateStart: Unknown Goal Span Type." );
      end if;
      @endnoparse
    end operation;

    @dialect("oal");
    operation evaluateAchievement() return GoalDisposition is
      @noparse
      // Based on the type of goal, determine whether this one is 
      //   currently being achieved and return a value indicating
      //   the disposition of the this goal.    
      
      // Find the related goal specification and workout session for this goal.
      select one goalSpec related by self->GoalSpec[R9.'specified_by'];
      select one session related by self->WorkoutSession[R11.'is_currently_executing_within'];
      
      // Based on the goal criteria type, get the appropriate current value
      //   for comparison against the criteria (minimum and maximum).
      currentValue = 0.0;  // Explicit declaration
      if ( goalSpec.criteriaType == GoalCriteria::HeartRate )
        currentValue = session.getCurrentHeartRate();
      elif ( goalSpec.criteriaType == GoalCriteria::Pace )
        currentValue = session.getCurrentPace();
      else
        LOG::LogFailure( message: "Goal.evaluateAchievement: Unknown Goal Criteria Type." );
      end if;
       
      // Compare the current value against the criteria to calculate the return value.
      goalDisposition = GoalDisposition::Achieving; 
      if ( currentValue < goalSpec.minimum )
        goalDisposition = GoalDisposition::Increase;
      elif ( currentValue > goalSpec.maximum )
        goalDisposition = GoalDisposition::Decrease;
      end if;
      
      // Invert the disposition value to produce a logical, semantic disposition for
      //   goal types, such as pace, that require it.
      if ( goalSpec.criteriaType == GoalCriteria::Pace )
        if ( goalDisposition == GoalDisposition::Increase )
          goalDisposition = GoalDisposition::Decrease;
        elif ( goalDisposition == GoalDisposition::Decrease )
          goalDisposition = GoalDisposition::Increase;
        end if;
      end if;
       
      return( goalDisposition );
      @endnoparse
    end operation;

    @dialect("oal");
    operation evaluateCompletion() is
      @noparse
      // Based on the span type for this goal, determine 
      //  whether it has been completed, update achievement
      //  records as necessary, and advance to the next goal
      //  if appropriate.
      
      select one goalSpec related by self->GoalSpec[R9.'specified_by'];
      
      // Based on the span type for the goal, get the elapsed span 
      //   for comparison against the specified span for the goal.
      elapsedSpan = 0.0;  // Explicit declaration
      if ( goalSpec.spanType == GoalSpan::Distance )
        select one session related by self->WorkoutSession[R11.'is_currently_executing_within'];
        elapsedSpan = session.accumulatedDistance - self.startingPoint;
      elif ( goalSpec.spanType == GoalSpan::Time )
        select one workoutTimer related by self->WorkoutSession[R11.'is_currently_executing_within']->WorkoutTimer[R8.'is_timed_by'];
        elapsedSpan = workoutTimer.time - self.startingPoint;
      else
        LOG::LogFailure( message: "Goal.evaluateCompletion: Unknown Goal Span Type." );
      end if;
      
      // Compare the current value against the specified span to determine 
      //   whether the execution of this workout goal is complete.
      if ( elapsedSpan >= goalSpec.span )
        select one openAchievement related by self->Achievement[R14.'has_open'];
        if ( not empty openAchievement )
          openAchievement.close();
        end if;
        generate Goal1:Completed to self;
      end if;
      @endnoparse
    end operation;

    @dialect("oal");
    class operation nextGoal() is
      @noparse
      // Advance to the next goal or start the first one if one
      //   is currently not exectuing.
      
      //  If there is a goal currently executing, notify it that its execution
      //    has completed.
      //  Otherwise, create and start a goal for the first goal specification
      //    if one exists.
      select any session from instances of WorkoutSession;  // WorkoutSession is a singleton.
      if ( not empty session )
        select one goal related by session->Goal[R11.'is_currently_executing'];
        if ( not empty goal )
          generate Goal1:Completed to goal;
        else
          GoalSpecConstants::initialize();
          select any gsc from instances of GoalSpecConstants;
          Goal::initialize( sequenceNumber: gsc.GoalSpecOrigin );
        end if;
      end if;
      @endnoparse
    end operation;

  end class;

end;
