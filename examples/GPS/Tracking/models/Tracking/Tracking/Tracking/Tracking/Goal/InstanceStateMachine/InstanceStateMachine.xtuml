// BP 7.1.6 content: InstanceStateMachine syschar: 3 persistence-version: 7.1.6

within Tracking::Tracking::Tracking::Tracking::Goal is

  @state_num(1);
  @dialect("oal");
  state Executing;

  @state_num(2);
  @dialect("oal");
  state Completed;

  @state_num(3);
  @dialect("oal");
  state Paused;

  @state_num(4);
  @dialect("oal");
  state Evaluating;

  //! Indicates that execution of this goal has been completed.
  @event_num(1);
  event Completed;

  //! Indicates that this goal should be evaluated for completeness and achievement.
  @event_num(2);
  event Evaluate;

  @event_num(3);
  event Pause;

  @event_num(4);
  event evaluationComplete;

  state machine is

    |                    | Completed          | Evaluate           | Pause              | evaluationComplete |
    | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ |
    | Executing          | Completed          | Executing          | Paused             | cannot_happen      |
    | Completed          | ignore             | ignore             | cannot_happen      | cannot_happen      |
    | Paused             | Completed          | Evaluating         | cannot_happen      | cannot_happen      |
    | Evaluating         | cannot_happen      | cannot_happen      | cannot_happen      | Executing          |

  end state machine;

  state Executing is
    @noparse
    // Determine whether this goal is currently being achieved.
    disposition = self.evaluateAchievement();
    
    // Update achievement records if necessary.  There are four cases:
    //   0. Still not achieving this goal. 
    //   1. Just started achieving this goal.
    //   2. Just stopped achieving this goal.
    //   3. Still achieving this goal.
    // For cases 0 and 3, there is nothing to be done for achievement records.
    // Case 1 requires the creation of a new achievment record, storing the start time.
    // Case 2 requires the storing of the end time for the open achievement record.
    if ( (self.disposition != GoalDisposition::Achieving) and (disposition == GoalDisposition::Achieving) )
      // Case 1, create achievement record, store start time, relate it as open record.
      select one workoutTimer related by self->WorkoutSession[R11.'is_currently_executing_within']->WorkoutTimer[R8.'is_timed_by'];
      create object instance achievement of Achievement; achievement.startTime = workoutTimer.time;
      relate self to achievement across R14.'has_open';
    elif ( (self.disposition == GoalDisposition::Achieving) and (disposition != GoalDisposition::Achieving) )
      // Case 2, store end time, relate as recorded record, unrelate as open record.
      select one achievement related by self->Achievement[R14.'has_open'];
      achievement.close();
    end if;
    
    // Update disposition of this goal.
    self.disposition = disposition;
    
    // Determine whether execution of this goal is complete, 
    //  and if so, advance to the next one if it exists.
    self.evaluateCompletion();
    @endnoparse
  end state;

  state Completed is
    @noparse
    // Stop executing this goal and begin executing the next one, if there is one.
    
    // Stop the goal-evaluation timer, ignoring the return code which indicates 
    //   whether a timer event was in flight when the timer was cancelled.
    cancelSucceeded = TIM::timer_cancel( timer_inst_ref: self.evaluationTimer );
    
    // If this goal has an open achievement record, close it.
    select one openAchievement related by self->Achievement[R14.'has_open'];
    if ( not empty openAchievement )
      openAchievement.close();
    end if;
    
    // Add this goal to the collection of those that have already executed.
    select one session related by self->WorkoutSession[R11.'is_currently_executing_within'];
    relate self to session across R13.'was_executed_within';
    
    // Remove this goal from the collection of currently executing ones.
    unrelate self from session across R11.'is_currently_executing_within';
    
    // Find the next goal specification in the sequence and start executing it, if it exists.
    select one currentGoalSpec related by self->GoalSpec[R9.'specified_by'];
    
    select any nextGoalSpec related by session->GoalSpec[R10.'includes'] where ( selected.sequenceNumber == (currentGoalSpec.sequenceNumber + 1) );
      
    if ( not empty nextGoalSpec )
      Goal::initialize( sequenceNumber: nextGoalSpec.sequenceNumber );
    end if;
    @endnoparse
  end state;

  state Paused is
    @noparse
    // Deactivate evaluation timer, ignoring the return code because this 
    //   state model ignores any latent timer events.
    cancelSucceeded = TIM::timer_cancel( timer_inst_ref: self.evaluationTimer );
    @endnoparse
  end state;

  state Evaluating is
    @noparse
    // Start a timer that periodically causes evaluation of goal achievement.
    GoalAchievement::initialize();
    select any goalachievement from instances of GoalAchievement;
    create event instance evaluateEvent of Goal2:Evaluate to self; self.evaluationTimer = TIM::timer_start_recurring( event_inst: evaluateEvent, microseconds: goalachievement.evaluationPeriod );
    
    generate Goal4:evaluationComplete() to self;
    @endnoparse
  end state;

end;
