// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within Tracking::Tracking::Tracking::Tracking is

  //! The collection of track points stored during a workout session.
  //! 
  //! Presently the device supports only a single track log, and it
  //! is always the active one for the current workout session.
  //! However, future releases may add a capability for storing
  //! multiple track logs on the device.
  @key_letters("TrackLog");
  @class_num(2);
  class TrackLog is

    @ref_mode("referred_to");
    @use_prefix(prefix="session_", root_name="startTime");
    session_startTime: referential (R4.WorkoutSession.startTime) timestamp;

    @ref_mode("referred_to");
    @use_prefix(prefix="start_", root_name="time");
    start_time: referential (R1.TrackPoint.time) integer;

    @ref_mode("referred_to");
    @use_prefix(prefix="end_", root_name="time");
    end_time: referential (R3.TrackPoint.time) integer;

    preferred identifier is (session_startTime);

    @dialect("oal");
    operation addTrackPoint(latitude: in real, longitude: in real) is
      @noparse
      // Add a track point to this track log, update the accumulated distance
      // and current speed, and then notify the UI.
      
      // Create a new track point, retrieving the current location from the GPS.
      select one workoutTimer related by self->WorkoutSession[R4.'represents_path_for']->WorkoutTimer[R8.'is_timed_by'];
      create object instance trackPoint of TrackPoint; trackPoint.time = workoutTimer.time;
      trackPoint.latitude = param.latitude;
      trackPoint.longitude = param.longitude;
      
      // Add the newly created track point to the track log.
      select one firstPoint related by self->TrackPoint[R1];
      select one lastPoint related by self->TrackPoint[R3];
      
      // Explicit variable declarations for later use outside if-else clause.
      isFirstTrackPoint = false;
      lastLatitude = 0.0;
      lastLongitude = 0.0;  
      if (empty firstPoint)
        isFirstTrackPoint = true;
        relate self to trackPoint across R1.'has_first';
        relate self to trackPoint across R3.'has_last';
      else 
        // Save last location for use in updating accumulated distance.
        lastLatitude = lastPoint.latitude;
        lastLongitude = lastPoint.longitude;
        unrelate self from lastPoint across R3.'has_last';
        relate self to trackPoint across R3.'has_last';
        relate lastPoint to trackPoint across R2.'follows';
      end if;
      
      // Update accumulated distance and current speed.
      distance = 0.0;
      if (not isFirstTrackPoint)
        distance = ::getDistance( fromLat: lastLatitude, fromLong: lastLongitude, toLat: trackPoint.latitude, toLong: trackPoint.longitude );
      end if;
      
      select one session related by self->WorkoutSession[R4.'represents_path_for'];
      session.accumulatedDistance = session.accumulatedDistance + distance;
      
      // Notify display of of the updated values.
      self.updateDisplay();
      @endnoparse
    end operation;

    @dialect("oal");
    operation clearTrackPoints() is
      @noparse
      select one nextPoint related by self->TrackPoint[R1];
      select one lastPoint related by self->TrackPoint[R3];
      
      if (not empty lastPoint)
        unrelate self from lastPoint across R3;
      end if;
      
      if (not empty nextPoint)
        unrelate self from nextPoint across R1;
      end if;
      
      while (not empty nextPoint)
        prevPoint = nextPoint;
        select one nextPoint related by nextPoint->TrackPoint[R2.'follows'];
        if ( not_empty nextPoint )
          unrelate prevPoint from nextPoint across R2.'follows';
        end if;
        delete object instance prevPoint;
      end while;
      @endnoparse
    end operation;

    @dialect("oal");
    operation addLapMarker() is
      @noparse
      select one timer related by self->WorkoutSession[R4.'represents_path_for']->WorkoutTimer[R8.'is_timed_by'];
      create object instance lapMarker of LapMarker; lapMarker.lapTime = timer.time; 
      relate self to lapMarker across R5.'has_laps_defined_by';
      
      // Notify display of the new value.
      self.updateDisplay();
      @endnoparse
    end operation;

    @dialect("oal");
    operation clearLapMarkers() is
      @noparse
      select many lapMarkers related by self->LapMarker[R5];
      for each lapMarker in lapMarkers
        unrelate self from lapMarker across R5;
        delete object instance lapMarker;
      end for;
      @endnoparse
    end operation;

    @dialect("oal");
    operation updateDisplay() is
      @noparse
      // Update the display so that newly updated values will be shown.
      select one display related by self->WorkoutSession[R4.'represents_path_for']->Display[R7.'current_status_indicated_on'];
      generate Display2:refresh to display;
      @endnoparse
    end operation;

  end class;

end;
