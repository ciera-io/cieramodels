// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within Tracking::Tracking::Tracking::Tracking is

  //! Each instance represents a single workout session.
  //! 
  //! Presently, the device supports only a single session,
  //! but future releases may support multiple sessions.
  //! Even in that case, only a single session is executing
  //! at any given time.  Other sessions represent completed
  //! or planned workout sessions.
  @key_letters("WorkoutSession");
  @class_num(7);
  class WorkoutSession is

    //! UTC time at which this session commenced.
    startTime: timestamp;

    //! Accumulated distance, expressed in meters, for this workout session.
    accumulatedDistance: real;

    preferred identifier is (startTime);

    @dialect("oal");
    operation addHeartRateSample(heartRate: in integer) is
      @noparse
      // Add a new heart-rate sample and notify the UI of the current heart rate.
      
      select one workoutTimer related by self->WorkoutTimer[R8.'is_timed_by'];
      
      // Create and initialize a new heart-rate sample.
      create object instance sample of HeartRateSample; sample.time = workoutTimer.time;
      sample.heartRate = param.heartRate;
      relate self to sample across R6.'tracks_heart_rate_over_time_as';
      
      // Notify UI of the new heart rate.
      select one display related by self->Display[R7.'current_status_indicated_on'];
      generate Display2:refresh to display;
      @endnoparse
    end operation;

    @dialect("oal");
    operation clearHeartRateSamples() is
      @noparse
      select many samples related by self->HeartRateSample[R6];
      for each sample in samples
        unrelate self from sample across R6;
        delete object instance sample;
      end for;
      @endnoparse
    end operation;

    @dialect("oal");
    class operation initialize() is
      @noparse
      // Unless a workout session already exists, create and initialize a 
      // workout session, workout timer, and tracklog, and relate them all.
      
      select any session from instances of WorkoutSession;
      
      if ( empty session )
      
        // Create a workout session.
        create object instance session of WorkoutSession;
        session.startTime = TIM::current_clock();
        session.accumulatedDistance = 0.0;
      
        // Create a workout timer.
        create object instance workoutTimer of WorkoutTimer;
        workoutTimer.initialize();
      
        // Create a track log.
        create object instance trackLog of TrackLog;
        
        // Create a display.
        create object instance display of Display;
      
        // Relate them all together.
        relate trackLog to session across R4.'represents_path_for';
        relate workoutTimer to session across R8.'acts_as_the_stopwatch_for';
        relate display to session across R7.'indicates_current_status_of';
        
      end if;
      @endnoparse
    end operation;

    @dialect("oal");
    operation reset() is
      @noparse
      // Reset this session, including the timer, track log, goal specifications,
      // goals, and achievement records.
      
      // Reset the timer.
      select one workoutTimer related by self->WorkoutTimer[R8.'is_timed_by'];
      workoutTimer.initialize();
      
      // Reset the track log.
      select one trackLog related by self->TrackLog[R4.'captures_path_in'];
      trackLog.clearTrackPoints();
      trackLog.clearLapMarkers();
      
      // Remove all goal specifications.
      select many goalSpecs related by self->GoalSpec[R10.'includes'];
      for each goalSpec in goalSpecs
        unrelate self from goalSpec across R10.'includes';
        delete object instance goalSpec;
      end for;
      
      // Remove any currently executing goal and open achievement record.
      select one executingGoal related by self->Goal[R11.'is_currently_executing'];
      if ( not empty executingGoal )
        select one openAchievement related by executingGoal->Achievement[R14.'has_open'];
        if ( not empty openAchievement )
          unrelate openAchievement from executingGoal across R14.'is_open_for';
          delete object instance openAchievement;
        end if;
        unrelate self from executingGoal across R11.'is_currently_executing';
        delete object instance executingGoal;
      end if;
      
      // Remove all other goals and achievement records.
      select many goals related by self->Goal[R13.'has_executed'];
      for each goal in goals
        select many achievements related by goal->Achievement[R12.'has_recorded'];
        for each achievement in achievements
          unrelate goal from achievement across R12.'has_recorded';
          delete object instance achievement;
        end for;
        unrelate self from goal across R13.'has_executed';
        delete object instance goal;
      end for;
      
      // Reset the session.
      self.accumulatedDistance = 0.0;
      self.clearHeartRateSamples();
      @endnoparse
    end operation;

    @dialect("oal");
    operation getCurrentSpeed() return real is
      @noparse
      // Calculate the current speed, expressed in km per hour, by summing 
      // the straight-line distance between each of several of the most recent 
      // track points and then dividing that sum by the elapsed time between 
      // the first and last point in the subset used for the calculation.
      
      select one lastPoint related by self->TrackLog[R4.'captures_path_in']->TrackPoint[R3.'has_last'];
      select one nextToLastPoint related by lastPoint->TrackPoint[R2.'preceeds'];
      speed = 0.0;
      if ( not empty lastPoint and not empty nextToLastPoint )
        cursor = lastPoint;
        Speed::initialize();
        select any spd from instances of Speed;
        index = spd.SpeedAveragingWindow;  // Number of track points to use when calculating average speed.
        totalDistance = 0.0;
        elapsedTime = 0.0;  // Explicit delcaration because a Real is required for a later calculation.
        elapsedTime = lastPoint.time;
        while ( index > 0 )
          select one previousPoint related by cursor->TrackPoint[R2.preceeds];
          if ( empty previousPoint )
            break;
          end if;
          distance = ::getDistance( fromLat:cursor.latitude, fromLong: cursor.longitude, toLat: previousPoint.latitude, toLong: previousPoint.longitude );
          totalDistance = totalDistance + distance;
          index = index - 1;
          cursor = previousPoint;
        end while;
        elapsedTime = elapsedTime - cursor.time;
        //speed = (totalDistance / 1000) / (elapsedTime / spd.SecondsPerHour); TODO issue #32
        kmDist = totalDistance / 1000;
        hourTm = elapsedTime / spd.SecondsPerHour;
        speed = kmDist / hourTm;
      end if;
      
      return speed;
      @endnoparse
    end operation;

    @dialect("oal");
    operation getCurrentPace() return real is
      @noparse
      // Calculate current pace from current speed, converting from km/hour to minutes/km.
      result = 0.0;
      if ( self.getCurrentSpeed() != 0.0 )
        result = 60.0 / self.getCurrentSpeed();
      else
        result = 0.0;
      end if;
      
      return result;
      @endnoparse
    end operation;

    @dialect("oal");
    operation getCurrentHeartRate() return integer is
      @noparse
      // Calculate sliding average using the most recent samples.
      
      HeartRateConstants::initialize();
      select any hrc from instances of HeartRateConstants;
      select one workoutTimer related by self->WorkoutTimer[R8.'is_timed_by'];
      select many samples related by self->HeartRateSample[R6.'tracks_heart_rate_over_time_as'] where ( selected.time >= ( workoutTimer.time - (hrc.HeartRateSamplingPeriod * hrc.HeartRateAveragingWindow) ) );
      numberOfSamples = 0;
      sum = 0;
      result = 0;
      for each sample in samples
        numberOfSamples = numberOfSamples + 1;
        sum = sum + sample.heartRate;
      end for;
      if ( numberOfSamples > 0 )
        result = sum / numberOfSamples;
      end if;
      
      return result;
      @endnoparse
    end operation;

  end class;

end;
